from numba import njit, cfunc
import numpy as np

jkw = dict(cache=True)


@cfunc('f8[:](f8, f8[:], f8[:])', **jkw)
def f_crtbp_ode(t, s, mc):
    """
    функция "выполнения" правой части системы уравнений для ОКЗТТ
    parameters:
        t: момент времени, для которого считается состояние системы
        s: вектор состояний системы (координаты, скорости и т.п.)
        mc: массив констант системы (в нашем случае константа координаты в упрощенной и обезразмеренной для задачи системе)
    returns:
        вектор левой части системы уравнений для ОКЗТТ (скорости, ускорения и т.п.)
    """
    x, y, z, vx, vy, vz = s
    mu2 = mc[0]
    mu1 = 1. - mu2

    r1 = ((x + mu2)**2 + y**2 + z**2)**0.5
    r2 = ((x - mu1)**2 + y**2 + z**2)**0.5

    ax = 2*vy + x - (mu1 * (x + mu2)/r1**3 + mu2 * (x - mu1)/r2**3)
    c = (mu1 / r1**3 + mu2 / r2**3)
    ay = -2*vx + y - c * y
    az = -c * z

    return np.array([vx, vy, vz, ax, ay, az])


@cfunc('f8[:](f8, f8[:], f8[:])', **jkw)
def lv_ode(t, s, mc):
    x, y = s
    a, b, c, d = mc
    return np.array([( a - b*y)*x,
                     (-c + d*x)*y])



@njit(**jkw)
def rk_Butcher_step(f, t, s, h, A, b, c, mc):
    """
    функция выполнения шага обобщенного алгоритма Рунге-Кутта размера h
    parameters:
        f: функция правой части системы
        t: момент времени
        s: состояние системы
        h: размер временного шага алгоритма
        A: матрица коэффициентов подстановки для каждого подшага k: f(..., s + (A[i], k))
        b: вектор коэффициентов для итогового суммирования: s_n = s_n-1 + b * k
        c: вектор коэффициентов времени для каждого подшага k: f(t + c[i] * h)
        mc: массив констант модели
    returns:
        s_res: вектор состояний на новом шаге алгоритма 
    """
    N = len(b)
    k = np.empty((N, s.shape[0]))
    s_res = s.copy()
    for i in range(N):
        t_0 = t + h * c[i]
        s_0 = s.copy()
        for j in range(i):
            s_0 += A[i,j]*h*k[j]
        k[i, :] = f(t_0, s_0, mc)
        s_res += h * b[i] * k[i]
    return s_res


@njit(**jkw)
def rk_Butcher_nsteps(f, t, s, h, b_t, mc, n):
    """
    функция решения произвольной задачи Коши на n шагов
    обобщённым методом Рунге-Кутты с таблицей Бутчера
    parameters:
        f: функция правой части системы
        t: момент времени
        s: начальное состояние системы (из явного условия системы Коши)
        h: размер временного шага алгоритма
        b_t: кортеж таблицы Бутчера, в который входит матрица A и вектора b, c
        mc: массив констант модели
        n: кол-во шагов
    """
    A, b, c = b_t
    arr = np.empty((n + 1, s.shape[0] + 1))
    arr[:, 0] = t + h * np.arange(n + 1)
    arr[0, 1:] = s
    for i in range(n):
        arr[i + 1, 1:] = rk_Butcher_step(
                                  f,           # правая часть СОДУ
                                  arr[i, 0],   # t_0
                                  arr[i, 1:],  # s_0
                                  h,           # шаг dt
                                  A,b,c, #таблица Бутчера
                                  mc # параметры модели
                                  )  
    return arr


@njit(**jkw)
def rk_Butcher_nsteps_planes(f, t, s, h, b_t, mc, n, pl):
    """
    функция решения произвольной задачи Коши на n шагов
    обобщённым методом Рунге-Кутты с таблицей Бутчера;
    имеет модификацию в виде условия остановки
    parameters:
        f: функция правой части системы
        t: момент времени
        s: начальное состояние системы (из явного условия системы Коши)
        h: размер временного шага алгоритма
        b_t: кортеж таблицы Бутчера, в который входит матрица A и вектора b, c
        mc: массив констант модели
        n: кол-во шагов
    """
    A, b, c = b_t
    arr = np.empty((n + 1, s.shape[0] + 1))
    arr[:, 0] = t + h * np.arange(n + 1)
    arr[0, 1:] = s
    
    i = 0
    for i in range(n):
        arr[i + 1, 1:] = rk_Butcher_step(
                                  f,           # правая часть СОДУ
                                  arr[i, 0],   # t_0
                                  arr[i, 1:],  # s_0
                                  h,           # шаг dt
                                  A,b,c, #таблица Бутчера
                                  mc # параметры модели
                                  ) 
        x = arr[i + 1, 1]
        if x < pl[0] or x > pl[1]:
            break

    return arr[:i + 2]